<!-- index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Static PDF Editor (client-side)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, Arial, sans-serif; margin: 0; background:#f3f4f6; }
    #toolbar { padding: 10px; background: #111827; color: white; display:flex; gap:8px; align-items:center; }
    #toolbar button, #toolbar input[type=file] { padding:8px 12px; border-radius:6px; border:none; cursor:pointer; }
    #container { padding: 12px; display:flex; gap:12px; }
    #viewer { flex:1; max-width: 1100px; }
    .pageWrap { position:relative; margin-bottom:20px; box-shadow:0 6px 18px rgba(0,0,0,0.12); background: white; display:inline-block; }
    canvas.pdfCanvas { display:block; }
    .overlay { position:absolute; left:0; top:0; }
    .edText { min-width:60px; min-height:20px; padding: 4px; border: 1px dashed rgba(0,0,0,0.3); background: rgba(255,255,255,0.85); cursor:move; resize:both; overflow:auto; }
    .edImg { position:absolute; cursor:move; border:1px dashed rgba(0,0,0,0.3); }
    .selected { outline:2px solid #3b82f6; }
    #sidebar { width:260px; }
    label { font-size:13px; color:#e5e7eb; }
    #status { margin-left:auto; color:#d1d5db; font-size:13px; }
  </style>
</head>
<body>
  <div id="toolbar">
    <input id="fileInput" type="file" accept="application/pdf"/>
    <button id="btnAddText">Add text</button>
    <input id="imgInput" type="file" accept="image/*" style="display:none"/>
    <button id="btnAddImage">Add image</button>
    <button id="btnExport">Export PDF</button>
    <div id="status">No PDF loaded</div>
  </div>

  <div id="container">
    <div id="viewer"></div>
    <div id="sidebar">
      <h3 style="margin:8px 0">Selected</h3>
      <div id="selProps">None</div>
      <hr/>
      <p style="font-size:13px;color:#374151">Tip: click a text block to edit it. Drag to move. Resize via corner (for text use contentEditable). Delete selected with DEL key.</p>
      <p style="font-size:13px;color:#374151">This is a static/browser-only editor — the original PDF is preserved and the edits are composited on export.</p>
    </div>
  </div>

  <!-- PDF.js (render) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.10.111/build/pdf.min.js"></script>
  <!-- pdf-lib (export/edit) -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

  <script>
  (async function(){
    // config
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.10.111/build/pdf.worker.min.js';

    const fileInput = document.getElementById('fileInput');
    const viewer = document.getElementById('viewer');
    const btnAddText = document.getElementById('btnAddText');
    const btnAddImage = document.getElementById('btnAddImage');
    const imgInput = document.getElementById('imgInput');
    const btnExport = document.getElementById('btnExport');
    const status = document.getElementById('status');
    const selProps = document.getElementById('selProps');

    let pdfData = null; // original ArrayBuffer
    let pdfDocJS = null; // pdf.js document
    let pages = []; // array of {canvas, scale, width, height, pageNumber, overlay}
    let selectedEl = null;

    fileInput.addEventListener('change', async (e) => {
      if (!e.target.files[0]) return;
      const f = e.target.files[0];
      pdfData = await f.arrayBuffer();
      await renderPDF(pdfData);
      status.textContent = `Loaded: ${f.name}`;
    });

    async function renderPDF(arrayBuffer) {
      viewer.innerHTML = '';
      pages = [];
      pdfDocJS = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
      for (let i=1;i<=pdfDocJS.numPages;i++){
        const page = await pdfDocJS.getPage(i);
        const viewport = page.getViewport({scale:1.5});
        const canvas = document.createElement('canvas');
        canvas.className = 'pdfCanvas';
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        await page.render({canvasContext: ctx, viewport}).promise;

        const wrap = document.createElement('div');
        wrap.className = 'pageWrap';
        wrap.style.width = canvas.width + 'px';
        wrap.style.height = canvas.height + 'px';
        wrap.dataset.pagenumber = i;

        const overlay = document.createElement('div');
        overlay.className = 'overlay';
        overlay.style.width = canvas.width + 'px';
        overlay.style.height = canvas.height + 'px';
        overlay.style.left = 0;
        overlay.style.top = 0;

        wrap.appendChild(canvas);
        wrap.appendChild(overlay);
        viewer.appendChild(wrap);

        pages.push({canvas, overlay, width:canvas.width, height:canvas.height, pageNumber:i});
      }
    }

    // Utilities: dragging/resizing handlers (simple)
    function makeDraggable(el) {
      el.onmousedown = (ev) => {
        if (ev.button !== 0) return;
        selectElement(el);
        const rect = el.getBoundingClientRect();
        const startX = ev.clientX, startY = ev.clientY;
        const offsetX = startX - rect.left, offsetY = startY - rect.top;
        function onMove(e) {
          el.style.left = (e.clientX - offsetX - rect.parentElement.getBoundingClientRect().left) + 'px';
          el.style.top = (e.clientY - offsetY - rect.parentElement.getBoundingClientRect().top) + 'px';
        }
        function done() { window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', done); }
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', done);
      };
    }

    // Selection
    function selectElement(el) {
      if (selectedEl) selectedEl.classList.remove('selected');
      selectedEl = el;
      if (el) el.classList.add('selected');
      updateSidebar();
    }
    function updateSidebar(){
      if (!selectedEl){ selProps.innerHTML = 'None'; return; }
      const type = selectedEl.dataset.type;
      const left = selectedEl.style.left || '0px';
      const top = selectedEl.style.top || '0px';
      const w = selectedEl.style.width || selectedEl.offsetWidth+'px';
      const h = selectedEl.style.height || selectedEl.offsetHeight+'px';
      selProps.innerHTML = `<b>Type:</b> ${type}<br/><b>Left:</b> ${left}<br/><b>Top:</b> ${top}<br/><b>W:</b> ${w}<br/><b>H:</b> ${h}`;
    }

    // Add Text
    btnAddText.addEventListener('click', () => {
      if (!pages.length) return alert('Load a PDF first');
      // add to first page by default
      const page = pages[0];
      const t = document.createElement('div');
      t.contentEditable = true;
      t.className = 'edText';
      t.innerText = 'New text';
      t.style.position = 'absolute';
      t.style.left = '40px';
      t.style.top = '40px';
      t.style.width = '160px';
      t.style.height = '40px';
      t.dataset.type = 'text';
      page.overlay.appendChild(t);
      makeDraggable(t);
      // allow resizing via native CSS resizing for text
      t.addEventListener('click', ()=> selectElement(t));
      selectElement(t);
    });

    // Add Image
    btnAddImage.addEventListener('click', () => imgInput.click());
    imgInput.addEventListener('change', async (e) => {
      const file = e.target.files[0]; if (!file) return;
      const dataUrl = await readFileAsDataURL(file);
      addImageOverlay(dataUrl);
      imgInput.value = '';
    });

    async function addImageOverlay(dataUrl) {
      if (!pages.length) return alert('Load a PDF first');
      const page = pages[0];
      const img = document.createElement('img');
      img.src = dataUrl;
      img.className = 'edImg';
      img.style.left = '40px';
      img.style.top = '80px';
      img.style.width = '160px';
      img.style.height = '100px';
      img.dataset.type = 'image';
      page.overlay.appendChild(img);
      makeDraggable(img);
      img.addEventListener('click', ()=> selectElement(img));
      // simple resize handle: use CSS width/height editing by double-click for now
      img.ondblclick = () => {
        const newW = prompt('Width px', img.style.width.replace('px','')) || img.style.width;
        const newH = prompt('Height px', img.style.height.replace('px','')) || img.style.height;
        img.style.width = (typeof newW === 'string' ? newW : newW + 'px');
        img.style.height = (typeof newH === 'string' ? newH : newH + 'px');
        updateSidebar();
      };
      selectElement(img);
    }

    function readFileAsDataURL(file){ return new Promise(res => { const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(file); })}

    // keyboard delete
    window.addEventListener('keydown', (e) => {
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedEl){
        selectedEl.remove();
        selectedEl = null;
        updateSidebar();
      }
    });

    // Export: build new PDF with pdf-lib
    btnExport.addEventListener('click', async () => {
      if (!pdfData) return alert('Load a PDF first');
      status.textContent = 'Exporting...';
      try {
        const uint8 = pdfData;
        const srcPdf = await PDFLib.PDFDocument.load(uint8);
        const outPdf = await PDFLib.PDFDocument.create();

        // Embed a standard font
        const font = await outPdf.embedFont(PDFLib.StandardFonts.Helvetica);

        for (const p of pages) {
          // embed original page into new pdf
          const [embedded] = await outPdf.embedPdf(uint8, [p.pageNumber - 1]);
          const { width:pw, height:ph } = embedded.size;
          const pageOut = outPdf.addPage([pw, ph]);
          // draw the embedded original page as background
          pageOut.drawPage(embedded);

          // now composite overlays
          // find overlay children
          const children = Array.from(p.overlay.children);
          for (const child of children) {
            const type = child.dataset.type;
            // compute position and scale: overlay coordinates start top-left
            // PDF coordinate origin is bottom-left
            const overlayRect = child.getBoundingClientRect();
            const parentRect = p.overlay.getBoundingClientRect();
            const relX = overlayRect.left - parentRect.left;
            const relY_top = overlayRect.top - parentRect.top;
            const relW = overlayRect.width;
            const relH = overlayRect.height;

            // convert to pdf-lib coordinates (bottom-left)
            // We rendered page to canvas of width p.width and height p.height
            // Embedded page has size [pw, ph] — assume same scale factor: map overlay pixels to PDF units
            const scaleX = pw / p.width;
            const scaleY = ph / p.height;
            const pdfX = relX * scaleX;
            const pdfY = (p.height - relY_top - relH) * scaleY; // bottom-left origin
            const pdfW = relW * scaleX;
            const pdfH = relH * scaleY;

            if (type === 'text') {
              const text = child.innerText || '';
              // basic wrapping: draw text at top-left of overlay box
              const fontSize = Math.max(8, Math.min(48, Math.round(pdfH * 0.6)));
              pageOut.drawText(text, {
                x: pdfX,
                y: pdfY + (pdfH - fontSize),
                size: fontSize,
                font,
                maxWidth: pdfW,
                lineHeight: fontSize * 1.1
              });
            } else if (type === 'image') {
              // embed the image from the element src (dataURL)
              try {
                const src = child.src;
                let imgBytes;
                if (src.startsWith('data:')) {
                  // convert dataURL to arrayBuffer
                  const res = await fetch(src);
                  imgBytes = await res.arrayBuffer();
                } else {
                  const res = await fetch(src);
                  imgBytes = await res.arrayBuffer();
                }
                // choose embedJpg or embedPng by mime
                let embeddedImg;
                if (child.src.startsWith('data:image/png') || child.src.endsWith('.png')) {
                  embeddedImg = await outPdf.embedPng(imgBytes);
                } else {
                  embeddedImg = await outPdf.embedJpg(imgBytes);
                }
                pageOut.drawImage(embeddedImg, { x: pdfX, y: pdfY, width: pdfW, height: pdfH });
              } catch (err) {
                console.error('Image embed failed', err);
              }
            }
          }
        }

        const saved = await outPdf.save();
        const blob = new Blob([saved], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'edited.pdf';
        a.click();
        URL.revokeObjectURL(url);
        status.textContent = 'Export complete';
      } catch (err) {
        console.error(err); alert('Export failed: '+err.message);
        status.textContent = 'Export failed';
      }
    });

    // small helper to select overlay when clicking outside child area
    viewer.addEventListener('click', (ev) => {
      if (ev.target === viewer) { selectElement(null); }
    });

  })();
  </script>
</body>
</html>
